<!doctype html>
<html lang="en-US">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <link rel="stylesheet" href="/main.3d00da4403468933e125edaaa0fd3f1c4dacf6d970d5130de45fa62f952af339aa6f9f622f4a35891e84d43de4e54156ed6fad0512598680291fb62f17e96153.css" integrity="sha512-PQDaRANGiTPhJe2qoP0/HE2s9tlw1RMN5F&#43;mL5Uq8zmqb59iL0o1iR6E1D3k5UFW7W&#43;tBRJZhoApH7YvF&#43;lhUw==" crossorigin="anonymous">
<noscript><style>img.lazyload { display: none; }</style></noscript>

<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;0,700;1,400;1,600&display=swap" rel="stylesheet">

  <meta name="robots" content="index, follow">
  <meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
  <meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
  <title>Read Replicas with VFS - Litestream</title>
<meta name="description" content="Litestream replicates SQLite databases in real-time to S3.">
<link rel="canonical" href="https://litestream.io/how-it-works/vfs/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://litestream.io/images/twitter-image.png">
<meta name="twitter:title" content="Read Replicas with VFS">
<meta name="twitter:description" content="The Litestream VFS serves SQLite reads directly from replica storage instead of restoring a full database file. It builds an index from LTX files, fetches pages on-demand, and keeps a cached view in sync by polling for new frames.
Replica layout &amp; restore plan Replicas store snapshots plus incremental LTX files on two levels:
L0: raw transactional files generated during replication. L1&#43;: compacted LTX files that merge older L0 segments. The VFS computes a restore plan before opening a connection.">
<meta name="twitter:site" content="@litestreamio">
<meta name="twitter:creator" content="@benbjohnson">

<meta name="twitter:site" content="@litestreamio">
<meta name="twitter:creator" content="@benbjohnson">

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position":  1 ,
        "name": "Home",
        "item": "https:\/\/litestream.io\/"
    },{
        "@type": "ListItem",
        "position":  2 ,
        "name": "How It Works",
        "item": "https:\/\/litestream.io\/how-it-works\/"
    },{
        "@type": "ListItem",
        "position":  3 ,
        "name": "Vfs",
        "item": "https:\/\/litestream.io\/how-it-works\/vfs\/"
    }]
}
</script>

  <meta name="theme-color" content="#fff">
<link rel="apple-touch-icon" sizes="180x180" href="https://litestream.io/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://litestream.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://litestream.io/favicon-16x16.png">
<link rel="manifest" href="https://litestream.io/site.webmanifest">
  
</head>
  <body class="how-it-works single">
    <header class="navbar fixed-top navbar-expand-md navbar-light">
  <div class="container align-items-baseline">
    <input class="menu-btn order-0" type="checkbox" id="menu-btn">

    <label class="menu-icon d-md-none" for="menu-btn"><span class="navicon"></span></label>

    <a class="navbar-brand order-1 order-md-0 mr-auto" href="https://litestream.io/">
      <img class="d-md-inline d-none" src="/images/logo.svg" />
      <span class="d-sm-inline d-md-none">Litestream</span>
    </a>

    <ul class="navbar-nav social-nav order-3 order-md-5">
      <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/litestreamio"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg><span class="ml-2 sr-only">Twitter</span></a>
        </li>
      <li class="nav-item">
          <a class="nav-link" href="https://github.com/benbjohnson/litestream"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg><span class="ml-2 sr-only">GitHub</span></a>
        </li>
      </ul>

    <div class="collapse navbar-collapse order-4 order-md-1">
      <ul class="navbar-nav main-nav mr-auto order-5 order-md-2"><li class="nav-item">
            <a class="nav-link" href="https://litestream.io/install">Install</a>
          </li>
        <li class="nav-item">
            <a class="nav-link" href="https://litestream.io/guides">Guides</a>
          </li>
        <li class="nav-item">
            <a class="nav-link" href="https://litestream.io/reference">Reference</a>
          </li>
        <li class="nav-item">
            <a class="nav-link" href="https://github.com/benbjohnson/litestream">GitHub</a>
          </li>
        <li class="nav-item">
            <a class="nav-link" href="https://join.slack.com/t/litestream/shared_invite/zt-3ed89j5s4-KODYR5v93N_0vHE_kDWCyg">Slack</a>
          </li>
        </ul>
      <div class="break order-6 d-md-none"></div>
    </div>
  </div>
</header>
    <div class="version-banner alert alert-warning text-center mb-0" role="alert" style="border-radius: 0;">
  <div class="container">
    <strong>v0.5.x</strong> - Latest - Actively maintained with new features and bug fixes| <a href="/v0.3/" class="alert-link">View v0.3.13 (Previous)</a></div>
</div>
    <div class="wrap container" role="document">
      <div class="content">
        
	<div class="row flex-xl-nowrap">
		<div class="col-lg-5 col-xl-4 docs-sidebar">
			<nav class="docs-links" aria-label="Main navigation">
				<h3>
    <a href="https://litestream.io/install">Install</a>
  </h3>
  <ul class="list-unstyled">
    <li><a class="docs-link" href="https://litestream.io/install/mac/">macOS</a></li>
    <li><a class="docs-link" href="https://litestream.io/install/linux/">Linux</a></li>
    <li><a class="docs-link" href="https://litestream.io/install/source/">Build from Source</a></li>
    </ul>
  <h3>
    <a href="https://litestream.io/">General</a>
  </h3>
  <ul class="list-unstyled">
    <li><a class="docs-link" href="https://litestream.io/getting-started/">Getting Started</a></li>
    <li><a class="docs-link" href="https://litestream.io/tips/">Tips &amp; Caveats</a></li>
    <li><a class="docs-link active" href="https://litestream.io/how-it-works/">How it works</a></li>
    <li><a class="docs-link active" href="https://litestream.io/how-it-works/vfs/">Read Replicas with VFS</a></li>
    <li><a class="docs-link" href="https://litestream.io/alternatives/">Alternatives</a></li>
    </ul>
  <h3>
    <a href="https://litestream.io/guides/">Infrastructure Guides</a>
  </h3>
  <ul class="list-unstyled">
    <li><a class="docs-link" href="https://litestream.io/guides/docker/">Running in a Docker container</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/kubernetes/">Running in a Kubernetes cluster</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/systemd/">Running as a Systemd service</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/windows/">Running as a Windows Service</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/directory-watcher/">Directory Watcher</a></li>
    </ul>
  <h3>
    <a href="https://litestream.io/guides/">Replica Guides</a>
  </h3>
  <ul class="list-unstyled">
    <li><a class="docs-link" href="https://litestream.io/guides/global-defaults/">Global Replica Defaults</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/s3/">Replicating to Amazon S3</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/aws-sdk-v2/">AWS SDK v2 Migration</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/alibaba-oss/">Replicating to Alibaba Cloud OSS</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/s3-advanced/">S3 Advanced Configuration</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/vfs/">VFS Read Replicas</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/go-library/">Using Litestream as a Go Library</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/vfs-write-mode/">VFS Write Mode</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/vfs-hydration/">VFS Hydration</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/azure/">Replicating to Azure Blob Storage</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/s3-compatible/">Replicating to S3-Compatible Services</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/backblaze/">Replicating to Backblaze B2</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/digitalocean/">Replicating to DigitalOcean Spaces</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/scaleway/">Replicating to Scaleway Object Storage</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/tigris/">Replicating to Tigris (Fly.io)</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/gcs/">Replicating to Google Cloud Storage</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/linode/">Replicating to Linode Object Storage</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/sftp/">Replicating to an SFTP Server</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/file/">Replicating to a Local File Path</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/nats/">Replicating to NATS JetStream</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/directory/">Replicating Directories</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/webdav/">Replicating to a WebDAV Server</a></li>
    </ul>
  <h3>
    <a href="https://litestream.io/docs/">Help</a>
  </h3>
  <ul class="list-unstyled">
    <li><a class="docs-link" href="https://litestream.io/docs/migration/">Migration Guide</a></li>
    <li><a class="docs-link" href="https://litestream.io/guides/wal-truncate-threshold/">WAL Truncate Threshold Configuration</a></li>
    <li><a class="docs-link" href="https://litestream.io/docs/troubleshooting/">Troubleshooting</a></li>
    </ul>
  <h3>
    <a href="https://litestream.io/reference/">Reference</a>
  </h3>
  <ul class="list-unstyled">
    <li><a class="docs-link" href="https://litestream.io/reference/config/">Configuration File</a></li>
    <li><a class="docs-link" href="https://litestream.io/reference/databases/">Command: databases</a></li>
    <li><a class="docs-link" href="https://litestream.io/reference/mcp/">Command: mcp</a></li>
    <li><a class="docs-link" href="https://litestream.io/reference/replicate/">Command: replicate</a></li>
    <li><a class="docs-link" href="https://litestream.io/reference/ltx/">Command: ltx</a></li>
    <li><a class="docs-link" href="https://litestream.io/reference/restore/">Command: restore</a></li>
    <li><a class="docs-link" href="https://litestream.io/reference/vfs/">VFS Extension</a></li>
    <li><a class="docs-link" href="https://litestream.io/reference/version/">Command: version</a></li>
    <li><a class="docs-link" href="https://litestream.io/reference/wal/">Command: wal</a></li>
    </ul>
  
			</nav>        
		</div>
		<nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation">
			<div class="page-links">
    <h3>On this page</h3>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#replica-layout--restore-plan">Replica layout &amp; restore plan</a></li>
    <li><a href="#page-based-access">Page-based access</a></li>
    <li><a href="#polling--l0l1-coordination">Polling &amp; L0/L1 coordination</a></li>
    <li><a href="#two-index-transaction-isolation">Two-index transaction isolation</a>
      <ul>
        <li><a href="#memory-implications-of-long-held-transactions">Memory implications of long-held transactions</a></li>
        <li><a href="#mitigations-already-in-place">Mitigations already in place</a></li>
      </ul>
    </li>
    <li><a href="#write-mode-architecture">Write mode architecture</a>
      <ul>
        <li><a href="#write-buffer-design">Write buffer design</a></li>
        <li><a href="#sync-process">Sync process</a></li>
        <li><a href="#conflict-detection">Conflict detection</a></li>
        <li><a href="#transaction-handling-during-sync">Transaction handling during sync</a></li>
      </ul>
    </li>
    <li><a href="#hydration-mechanism">Hydration mechanism</a>
      <ul>
        <li><a href="#streaming-compaction">Streaming compaction</a></li>
        <li><a href="#read-path-evolution">Read path evolution</a></li>
        <li><a href="#incremental-update-application">Incremental update application</a></li>
        <li><a href="#memory-management">Memory management</a></li>
      </ul>
    </li>
    <li><a href="#performance-model">Performance model</a></li>
    <li><a href="#compared-to-restore-first-workflows">Compared to restore-first workflows</a></li>
    <li><a href="#see-also">See Also</a></li>
  </ul>
</nav>
  </div>

		</nav>
		<main class="docs-content col-lg-11 col-xl-9 mx-xl-auto">
		<h1>Read Replicas with VFS</h1>
			<p class="lead"></p>
			<p>The Litestream VFS serves SQLite reads directly from replica storage instead of
restoring a full database file. It builds an index from LTX files, fetches pages
on-demand, and keeps a cached view in sync by polling for new frames.</p>
<h2 id="replica-layout--restore-plan">Replica layout &amp; restore plan<a href="#replica-layout--restore-plan" class="anchor" aria-hidden="true">#</a> </h2>
<p>Replicas store snapshots plus incremental LTX files on two levels:</p>
<ul>
<li><strong>L0</strong>: raw transactional files generated during replication.</li>
<li><strong>L1+</strong>: compacted LTX files that merge older L0 segments.</li>
</ul>
<p>The VFS computes a restore plan before opening a connection. It looks for a
contiguous LTX sequence, fails fast on gaps, and waits if no snapshot exists
yet. The database page size (512–65536 bytes) is detected from LTX headers.</p>
<h2 id="page-based-access">Page-based access<a href="#page-based-access" class="anchor" aria-hidden="true">#</a> </h2>
<p>For each LTX file in the plan, the VFS reads the page index and builds an
in-memory map of page number to LTX offset. Reads consult the map, fetch the
page bytes from storage, and cache them in an LRU cache sized by <code>CacheSize</code>
(default 10MB). The first page is rewritten to present <code>DELETE</code> journal mode so
SQLite treats the replica as a read-only rollback-journal database.</p>
<h2 id="polling--l0l1-coordination">Polling &amp; L0/L1 coordination<a href="#polling--l0l1-coordination" class="anchor" aria-hidden="true">#</a> </h2>
<p>A polling loop (default every 1s) scans for new LTX files:</p>
<ul>
<li>L0 is checked first; gaps at L0 are tolerated by deferring to higher levels.</li>
<li>L1 compactions replace the page index when commits shrink (e.g., after vacuum).</li>
<li>File descriptor &amp; network usage stay bounded by closing LTX streams after page
indexes are ingested.</li>
</ul>
<p>Retention of recent L0 files on the primary (<code>l0-retention</code>) is important so VFS
replicas can see fresh writes before they are compacted.</p>
<h2 id="two-index-transaction-isolation">Two-index transaction isolation<a href="#two-index-transaction-isolation" class="anchor" aria-hidden="true">#</a> </h2>
<p>The VFS maintains two in-memory page indexes to provide snapshot isolation
without blocking primary database writes:</p>
<ul>
<li><strong>Main index</strong>: Maps page numbers to LTX file offsets for the current
connection&rsquo;s view. Readers query this index during transactions.</li>
<li><strong>Pending index</strong>: Accumulates new LTX page entries that arrive while a read
transaction holds a shared lock.</li>
</ul>
<p>When a connection acquires a shared lock (starting a read transaction), the VFS
continues polling for new LTX files but stages their page entries in the pending
index rather than the main index. This mirrors SQLite&rsquo;s own transaction
isolation semantics: a read transaction sees a consistent snapshot of the
database as it existed when the transaction started.</p>
<p>When the lock is released (transaction ends), the pending entries atomically
merge into the main index, and any cached pages for updated page numbers are
invalidated. The next transaction sees the fresh data.</p>
<h3 id="memory-implications-of-long-held-transactions">Memory implications of long-held transactions<a href="#memory-implications-of-long-held-transactions" class="anchor" aria-hidden="true">#</a> </h3>
<p>Because the pending index accumulates page entries during active read
transactions, holding a transaction open during sustained write activity causes
memory growth proportional to the write rate and transaction duration:</p>
<table>
<thead>
<tr>
<th>Write Rate</th>
<th>Transaction Duration</th>
<th>Approximate Pending Entries</th>
</tr>
</thead>
<tbody>
<tr>
<td>100 writes/sec</td>
<td>30 seconds</td>
<td>~3,000 entries</td>
</tr>
<tr>
<td>500 writes/sec</td>
<td>60 seconds</td>
<td>~30,000 entries</td>
</tr>
<tr>
<td>1,000 writes/sec</td>
<td>60 seconds</td>
<td>~60,000 entries</td>
</tr>
</tbody>
</table>
<p>Each pending entry is a small map entry (page number to LTX offset), so memory
overhead is modest—typically a few bytes per entry. However, sustained
high-write scenarios with long-held transactions can accumulate tens of
thousands of entries.</p>
<p>This behavior is working as designed and mirrors SQLite&rsquo;s own semantics where
long-running read transactions prevent resource cleanup (WAL checkpointing on
the primary, pending index cleanup on VFS replicas).</p>
<h3 id="mitigations-already-in-place">Mitigations already in place<a href="#mitigations-already-in-place" class="anchor" aria-hidden="true">#</a> </h3>
<ul>
<li><strong>L0 retention</strong>: The primary&rsquo;s <code>l0-retention</code> setting ensures LTX files
remain available even as new files arrive, giving VFS clients time to
discover and index them.</li>
<li><strong>Bounded index growth</strong>: Normal page reuse means the same logical pages are
updated repeatedly, limiting unique entries.</li>
<li><strong>Design intent</strong>: The VFS targets read-replica workloads with moderate query
load, not high-concurrency OLTP scenarios.</li>
</ul>
<p>See the <a href="/guides/vfs/#transaction-duration--memory">VFS guide</a> for practical
recommendations on transaction duration.</p>
<h2 id="write-mode-architecture">Write mode architecture<a href="#write-mode-architecture" class="anchor" aria-hidden="true">#</a> </h2>
<p>When write mode is enabled (<code>LITESTREAM_WRITE_ENABLED=true</code>), the VFS transitions
from read-only to read-write by adding a local write buffer and sync mechanism.</p>
<h3 id="write-buffer-design">Write buffer design<a href="#write-buffer-design" class="anchor" aria-hidden="true">#</a> </h3>
<ul>
<li>
<p><strong>Local buffer file</strong>: All writes go to a local SQLite database file that
serves as a write buffer. This file captures dirty pages before they are
synced to remote storage.</p>
</li>
<li>
<p><strong>Dirty page tracking</strong>: The VFS maintains a bitmap of which database pages
have been modified since the last sync. Only dirty pages are packaged into
LTX files.</p>
</li>
<li>
<p><strong>Crash recovery</strong>: The buffer file persists uncommitted changes. On restart,
buffered writes can be recovered and synced.</p>
</li>
</ul>
<h3 id="sync-process">Sync process<a href="#sync-process" class="anchor" aria-hidden="true">#</a> </h3>
<p>At each sync interval (default 1 second):</p>
<ol>
<li>
<p><strong>Check for conflicts</strong>: The VFS polls for new LTX files from other sources.
If new files are detected, a conflict is raised before uploading.</p>
</li>
<li>
<p><strong>Package dirty pages</strong>: Modified pages are read from the buffer and
packaged into a new LTX file with proper transaction ordering.</p>
</li>
<li>
<p><strong>Upload to replica</strong>: The new LTX file is uploaded to the configured
replica location.</p>
</li>
<li>
<p><strong>Reset buffer</strong>: After successful upload, the dirty page bitmap is cleared
and the buffer is ready for the next batch.</p>
</li>
</ol>
<h3 id="conflict-detection">Conflict detection<a href="#conflict-detection" class="anchor" aria-hidden="true">#</a> </h3>
<p>Since write mode assumes a single writer, the VFS uses optimistic conflict
detection:</p>
<ul>
<li>Before each sync, check if the remote TXID has advanced unexpectedly.</li>
<li>If another writer has uploaded new LTX files, the sync is aborted.</li>
<li>The application receives a conflict error and must decide how to proceed.</li>
</ul>
<p>This approach avoids the complexity of distributed locking while providing
safety through detection. Applications can implement retry logic, external
locking, or accept last-writer-wins semantics depending on their requirements.</p>
<h3 id="transaction-handling-during-sync">Transaction handling during sync<a href="#transaction-handling-during-sync" class="anchor" aria-hidden="true">#</a> </h3>
<ul>
<li>
<p><strong>In-flight transactions</strong>: Active transactions continue using the local
buffer while sync runs in the background.</p>
</li>
<li>
<p><strong>Commit visibility</strong>: Local commits are immediately visible to the same
connection but not to remote readers until the next sync completes.</p>
</li>
<li>
<p><strong>Sync isolation</strong>: The sync process reads a consistent snapshot of dirty
pages without blocking ongoing writes.</p>
</li>
</ul>
<h2 id="hydration-mechanism">Hydration mechanism<a href="#hydration-mechanism" class="anchor" aria-hidden="true">#</a> </h2>
<p>When hydration is enabled (<code>LITESTREAM_HYDRATION_ENABLED=true</code>), the VFS
restores the complete database to a local file while continuing to serve
reads from cache and remote storage.</p>
<h3 id="streaming-compaction">Streaming compaction<a href="#streaming-compaction" class="anchor" aria-hidden="true">#</a> </h3>
<p>Hydration builds the local database through streaming compaction:</p>
<ol>
<li>
<p><strong>Compute restore plan</strong>: Like the standard VFS, determine the sequence of
LTX files needed to reconstruct the database.</p>
</li>
<li>
<p><strong>Stream pages to disk</strong>: Instead of building only an in-memory index, write
the actual page data to a local SQLite database file.</p>
</li>
<li>
<p><strong>Incremental processing</strong>: Process LTX files one at a time, applying their
pages to the local file. Memory usage stays bounded regardless of database
size.</p>
</li>
<li>
<p><strong>Handle page overwrites</strong>: When newer LTX files update the same pages,
overwrite the local file&rsquo;s pages to maintain consistency.</p>
</li>
</ol>
<h3 id="read-path-evolution">Read path evolution<a href="#read-path-evolution" class="anchor" aria-hidden="true">#</a> </h3>
<p>The VFS read path changes as hydration progresses:</p>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Page lookup</th>
<th>Source</th>
</tr>
</thead>
<tbody>
<tr>
<td>Before hydration</td>
<td>Index → Remote LTX</td>
<td>Object storage</td>
</tr>
<tr>
<td>During hydration</td>
<td>Index → Remote LTX or cache</td>
<td>Object storage + cache</td>
</tr>
<tr>
<td>After hydration</td>
<td>Index → Local file</td>
<td>Local disk</td>
</tr>
</tbody>
</table>
<p>The transition is transparent: applications continue using the same connection
while the underlying read path improves.</p>
<h3 id="incremental-update-application">Incremental update application<a href="#incremental-update-application" class="anchor" aria-hidden="true">#</a> </h3>
<p>After initial hydration completes:</p>
<ol>
<li>
<p><strong>Continue polling</strong>: The VFS keeps polling for new LTX files from the primary.</p>
</li>
<li>
<p><strong>Apply to local file</strong>: New pages are written to the hydrated file, keeping
it synchronized with the replica.</p>
</li>
<li>
<p><strong>Cache invalidation</strong>: The in-memory cache is updated to reflect new data,
but reads now come from the local file.</p>
</li>
</ol>
<p>This ensures the hydrated database stays current without requiring re-hydration.</p>
<h3 id="memory-management">Memory management<a href="#memory-management" class="anchor" aria-hidden="true">#</a> </h3>
<p>Hydration is designed for bounded memory usage:</p>
<ul>
<li><strong>No full-database buffering</strong>: Pages are written directly to disk via streaming I/O.</li>
<li><strong>LTX streaming</strong>: Each LTX file is processed and released before moving to the next.</li>
<li><strong>Index overhead only</strong>: Memory usage is similar to standard VFS operation—just the page index plus cache.</li>
</ul>
<p>A 10GB database can be hydrated with the same memory footprint as serving it
read-only via standard VFS.</p>
<h2 id="performance-model">Performance model<a href="#performance-model" class="anchor" aria-hidden="true">#</a> </h2>
<ul>
<li>First access to a page incurs network/object-store latency; hot pages are
served from the VFS cache.</li>
<li>Polling frequency controls replication lag versus API call volume.</li>
<li>Sequential scans across large tables will generate sustained remote reads;
indexed lookups and repeated queries benefit most from caching.</li>
<li>Placing the VFS client in the same region as the replica minimizes added
latency (typically 5–50ms over local disk).</li>
</ul>
<h2 id="compared-to-restore-first-workflows">Compared to restore-first workflows<a href="#compared-to-restore-first-workflows" class="anchor" aria-hidden="true">#</a> </h2>
<p>The <code>restore</code> command downloads a full snapshot plus WAL/ltx chain, trading
startup time and disk space for local performance. The VFS avoids the download
and disk cost but introduces network latency and relies on contiguous replica
history. Choose VFS for light-weight read replicas and rapid spin-up; choose
restore for low-latency, write-capable workloads on local disk.</p>
<h2 id="see-also">See Also<a href="#see-also" class="anchor" aria-hidden="true">#</a> </h2>
<ul>
<li><a href="/guides/vfs">VFS Read Replicas Guide</a> - Step-by-step setup and usage</li>
<li><a href="/guides/vfs-write-mode">VFS Write Mode Guide</a> - Enable writes with remote sync</li>
<li><a href="/guides/vfs-hydration">VFS Hydration Guide</a> - Background restoration to local file</li>
<li><a href="/reference/vfs">VFS Extension Reference</a> - Complete API and configuration</li>
<li><a href="/docs/troubleshooting">Troubleshooting</a> - Common issues and solutions</li>
</ul>

			<div class="docs-navigation d-flex justify-content-between">
	
	</div>

		</main>
	</div>

      </div>
    </div>
    
    
    <footer>
</footer>
    
    <script src="https://litestream.io/main.f4006b8dd3163d19fa41adf9892089fe185101b404b96884ed2a22ec4e9cb0706759ecdb3f4520a1d37fc5ad7a90a8d90abfb30055a1ff67aefb5b2324355d12.js" integrity="sha512-9ABrjdMWPRn6Qa35iSCJ/hhRAbQEuWiE7Soi7E6csHBnWezbP0UgodN/xa16kKjZCr&#43;zAFWh/2eu&#43;1sjJDVdEg==" crossorigin="anonymous" defer></script>
  <script src="https://litestream.io/index.min.ccd7afc3bf63cd0223b56ebd09df96d936c9d4e9eff724d0a9c2556b109631cf49cf5b263d887d299545f0c361c9b8ff0bf1061aacf68d97b3ac1c2f74952d9f.js" integrity="sha512-zNevw79jzQIjtW69Cd&#43;W2TbJ1Onv9yTQqcJVaxCWMc9Jz1smPYh9KZVF8MNhybj/C/EGGqz2jZezrBwvdJUtnw==" crossorigin="anonymous" defer></script>

  </body>
</html>